useEffect(()=>{})
(callback func : 다른 함수의 인자로 전달된 함수)

useEffect(()=>{

});
- 렌더링 될때 마다 실행

useEffect(()=>{

},[]);
- 화면에 첫 렌더링 될때 실행

useEffect(()=>{

},[value]);
- 화면에 첫 렌더링 될때 실행
- value가 변할 때 실행

useEffect(()=>{

    return () => {
        // 언마운트, 다음 렌더링 시 useEffect 실행 전
    }
},[]);

================================================================================================
const ref = useRef(value)
{current : value}
- useRef의 인자 value는 ref current에 저장됨
- ref.current

- Component가 계속 렌더링 되도, 언마운트 전까진 값을 유지함
- ref 값은 변해도, state와 달리 렌더링이 되지 않음
    -> 렌더링 후 값 변화 확인 가능

- Usage
- 1)저장공간
cf)state
    - state 변화 -> 렌더링 -> (함수)컴포넌트 내부 변수들 초기화 (함수형 컴포넌트의 리렌더링 : 함수 재호출 / 원하지 않는 렌더링에 의해 장애 발생 가능)
- Ref 변화 -> No 렌더링 -> 변수들의 값이 유지됨
- State 변화 -> 렌더링 -> Ref의 값은 유지됨
- 자주 변하는 값 + 변화는 감지해야 하지만, 그 변화가 렌더링을 발생해선 안되는 경우 (app3)

- 2)DOM 요소에 접근
- focus()
    - 자동으로 focus 될 수 있도록 함
    -document.querySelector()
const ref = useRef(value)
<input ref={ref} />

================================================================================================
useContext
- data는 props를 통해 부모 태그에서 자식 태그로 전달됨 (prop drilling)
    - 전달하는 과정에서 데이터는 중간 과정을 거쳐야 하는 불필요한 작업이 필요함
- App에서 전역적으로 사용되는 데이터를 여러 component 끼리 전달하는 방법을 제시
- 사용자 정보, 테마, 언어
- conetxt 사용 시 컴포넌트 재사용하기 어려워 질 수 있음
    - prop drilling을 피하기 위해선 component composition을 선고려

export const ThemeContext = createContext(null);
- .Provider로 감싸고 value값을 전달하기 때문에 초기값이 필요 없음

export const ThemeContext = createContext('hello');
- .Provider로 감싸지 않음 + value가 없다면 초기값이 전달됨

================================================================================================
useReducer
- USAGE
- 여러개의 하위 값을 가진 복잡한 state를 다룰 때 사용
- Reducer / Dispatch / Action

- Reducer : State를 변경(update)함
- Dispatch : 변경 요구 / state 업데이트를 위한 요구
- Action : 요구 내용

Dispatch(Action) -> Reducer(State, Action)



